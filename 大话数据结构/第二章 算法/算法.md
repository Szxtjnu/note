<u>**程序设计=数据结构+算法**</u>





# 算法

#### 算法定义

***算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作***

#### 算法的特性

算法具有五个基本特性：输入、输出、有穷、确定、可行

1.  输入和输出

    算法具有零个或多个输入，算法至少有一个或多个输出。

2.  有穷性

    指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。

3.  确定性

    算法的每一步骤都具有确定的含义，不会出现二义性。

4.  可行性

    算法的每一步都是必须可行的，也就是说，每一步都能够通过执行有限的次数完成。

---

#### 算法设计的要求

##### 正确性

​	<u>算法的正确性是指算法至少应该具有输入输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</u>

##### 可读性

​	<u>算法设计的另一目的就是为了方便阅读、理解和交流</u>

##### 健壮性

​	<u>当输入数据不合法时，算法也能做出相关的处理，而不是产生异常或莫名其妙的结果</u>（例如：输入的时间或者距离不应该是负数）

##### ⭐时间效率高和存储量低

​	<u>时间效率指的是算法的执行时间。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。</u>

​	**设计算法应该尽量满足时间效率高和存储量低的需求**

---

#### 算法效率的度量方法

##### ~~事后统计方法~~

​	<u>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</u>

​	But 这样的方法有很大的缺陷：

1.  必须依据算法事先编制好程序，如果写出来的程序很糟糕，岂不是白写？
2.  时间的比较依赖的计算机硬件和软件等环境因素。不确定性较大，在不同的计算机上测得的结果可能不同。
3.  算法的测试数据设计困难，而且程序的运行时间往往和测试数据的规模有较大的关系

##### ✔事前分析估算方法

​	<u>在计算机程序编制前，依据统计方法对算法进行估算</u>

​	一个用高级语言编写的程序在计算机上运行时候所消耗的时间由以下几个因素决定

1.  算法采用的策略、方法
2.  编译产生的代码质量
3.  问题的输入规模
4.  机器执行指令的速度

其中，第一条是算法好坏的根本。

**一个程序的运行时间，依赖于算法的好坏和问题的输入规模(输入量的多少)**

​	下面我们拿两个算法来作比较

```c++
int i, sum = 0 , n = 100;	//执行1次
for( i = 1; i<=n; ++i){		//执行n+1次
	sum += i;				//执行n次
}	
printf("%d",sum);			//执行1次
```

```c++
int sum = 0, n = 100;		//执行1次
sum = ( 1 + n ) * n / 2;	//执行1次
printf("%d",sum);			//执行1次
```

显然，第一个算法执行了2n+3次，而第二个算法只执行了3次

***最终，在分析程序的运行时间时，最重要的是把程序看作是独立于程序设计语言的算法或一系列步骤***

****

#### 函数的渐近增长

**函数的渐近增长：给定的两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n<N ,f(n)总是比g(n)大，那么我们就说f(n)的增长渐近快于g(n)**

​	我们在计算时，有这么几个规律:

1.  通常将加法常数忽略
2.  计算时，与最高次项数的常数并不重要。
3.  最高次项的指数大的，函数随着n的增长，结果也会变得增长的特别快。
4.  判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，更应该关注最高次项的阶数

总之，对于某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。

---

#### 时间复杂度

##### 时间复杂度定义：

​	**在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。**

##### 推导大O阶方法

​	推导大O阶：

1.  用常数1取代运行时间中的所有加法常数；

2.  在修改后的运行次数函数中，只保留最高阶项；

3.  如果最高阶项存在且不是1，则去除与这个项相乘的常数；

    得到的结果就是大O阶。

##### 常数阶

​	顺序结构的时间复杂度。O(1)，其中，无论是程序中执行了几次，只要是算法执行的时间与问题大小无关，均为O(1)。1，不能改为别的常数。

##### 线性阶

​	对于线性阶的循环结构，我们要分析算法的时间复杂度，关键就是要分析循环结构的运行情况。

##### 对数阶

```c++
int count = 1;
while (count < n){
    count  = count * 2;
}
```

对于上面这个算法来说，每次count乘以2之后，就距离n更近了一分，也就是说，$2^x= n$得到$x=\log_2n$

##### 平方阶

下面这个例子是一个循环嵌套，内层循环的时间复杂度是O(n)

```cpp
int i,j;
for( i = 0; i < n; ++i){
    for( j = 0; j < n; ++j){
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```

​	这两层循环，都是循环n次，故，这个代码块的时间复杂度就是O(n²)	

​	如果外循环的循环次数改为m，则时间复杂度就变成了O(m×n)

##### 调用函数的时间复杂度的求法

就是将主函数体部分的时间复杂度算出来，再将函数部分的时间复杂度算出来，再根据他们之间的关系，用加法或者乘法求出最终的复杂度。

```cpp
n++;
function(n);
int i,j;
for( i = 0; i < n; ++i)
{
    function(i);
}
for( i = 0; i < n; ++i)
{
    for( j = i; j < n; ++j){
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```

---

#### 常见的时间复杂度

|   执行次数函数    |      阶      | 非正式术语 |
| :---------------: | :----------: | :--------: |
|        12         |     O(1)     |   常数阶   |
|       2n+3        |     O(n)     |   线性阶   |
|    $3n^2+2n+1$    |   O($n^2$)   |   平方阶   |
|   $5\log_2n+20$   | O($\log n$)  |   对数阶   |
| $2n+3n\log_2n+19$ | O($n\log n$) |  nlogn阶   |
| $6n^3+2n^2+3n+4$  |   O($n^3$)   |   立方阶   |
|       $2^n$       |   O($2^n$)   |   指数阶   |

**常用的时间复杂度所耗费的时间从小到大依次是：**

**O(1)<O($\log n$)<O(n)<O($nlog n$)<O($n^2$)<O($n^3$)<O($2^n$)<O(n!)<O($n^n$)**

---

##### 最坏情况与平均情况

​	当我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度就是O(1)，但也有可能这个数字就在最后一个位置上带着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况。

**最坏情况运行时间是一种保证，那就是运行时间就不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。**

**平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。**

​	对于算法的分析，一种是计算所有情况的平均值，这种时间复杂度的计算方法成为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法成为最坏时间复杂度。

---

#### 算法空间复杂度

**算法的空间复杂度通过计算算法所需要的存储空间的实现，算法的空间复杂度的计算公式记作:S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。**

若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1).