> ## 题目描述
>
> 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n张地毯，编号从 1 到 n这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。
>
> 地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。
>
> ## 输入输出格式
>
> **输入格式**
>
> 输入共 n + 2行。
>
> 第一行，一个整数 n，表示总共有 n 张地毯。
>
> 接下来的 n行中，第 i+1 行表示编号 i 的地毯的信息，包含四个整数 a ,b ,g ,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 (a, b) 以及地毯在 x轴和 y轴方向的长度。
>
> 第 n + 2行包含两个整数 x*x* 和 y，表示所求的地面的点的坐标 (x, y)。
>
> **输出格式**
>
> 输出共 1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。
>
> ## 输入输出样例
>
> 输入1 :
>
> ```
> 3
> 1 0 2 3
> 0 2 3 3
> 2 1 3 3
> 2 2
> ```
>
> 输出1 :
>
> ```
> 3
> ```
>
> 输入2 :
>
> ```
> 3
> 1 0 2 3
> 0 2 3 3
> 2 1 3 3
> 4 5
> ```
>
> 输出2 :
>
> ```
> -1
> ```

```cpp
#include<iostream>
#include<cstdio>
long long ditan[1000][1000] = {-1};
using namespace std;
int main() {
    int n, a, b, g, k;
    cin >> n;
    int x1, y1;
    for(int i = 1; i <= n; i ++){
        cin >> a >> b >> g >> k;
        int j, m;
        for(j = a; j <= a + g; j++){
            for(m = b; m <= b + k; m++){
                ditan[j][m] = i;
            }
        }
    }
    cin >> x1 >> y1;
    cout << ditan[x1][y1] << endl;
    return 0;
}
```

先把第一版代码贴上来，简单的说一下思路，读题后发现，我们需要知道最后覆盖在x,y 这个坐标上的地毯编号是多少？所以这里我首先的思路就是模拟一个坐标系，按照题目所给的步骤一步一步的来。模拟为二维数组，然后初始值均为-1，之后第一张地毯盖上去的时候，使用for循环来将所覆盖的地方都标记为1，之后一直到第n张。然后直接将二维数组中对应的(x,y)的数字输出即为地毯的编号。

这里可以很明显的看出这样的解法是非常消耗时间和空间的，所以最后只有50分。

那么第二版的思路是这样的：

首先，我们想知道这个点上面的地毯编号，那么我们就得先知道这个点上面有没有地毯。假如说所给的(x,y)在地毯最左下坐标，到最右上坐标的范围内，那么我们就可以判定这个点是被这张地毯所覆盖。

其次，我们要求的是覆盖这个(x,y)坐标点最上层的地毯编号，所以我们并不需要从开头来模拟这个过程，我们可以模拟掀开地毯的这个动作，即从第n张地毯开始判断，假如说我们要求的这个坐标(x,y)在这个范围内，我们直接输出break就可以了。大幅度的减少了所需要的时间和空间。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
    int n;
    cin >> n;
    int a[10005], b[10005], g[10005], k[10005];
    //存放所需的坐标值
    for(int i = 1; i <= n; i++){
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);
    }
    int x, y;
    cin >> x >> y;//输入判定的坐标
    int j;
    for(j = n; j > 0; j--){
        if(x>=a[j] && y>=b[j] && x<=(a[j]+g[j]) && y<=(b[j]+k[j])) //如果所需判定的坐标在地毯的范围内
        {
            cout << j << endl; //输出地毯编号
            break;
        }
    }
    if(j == 0)  cout << -1;//否则输出-1
    return 0;
}
```

