> ## 题目背景
>
> NOIP2016 提高组 D1T1
>
> ## 题目描述
>
> 小南有一套可爱的玩具小人, 它们各有不同的职业。
>
> 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图:
>
> ![img](https://cdn.luogu.com.cn/upload/image_hosting/0u7em9pi.png)
>
> 这时singer告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第11个玩具小人的左数第22个玩具小人那里。 ”
>
> 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。
>
> 小南一边艰难地辨认着玩具小人, 一边数着:
>
> singer朝内, 左数第33个是archer。
>
> archer朝外,右数第11个是thinker。
>
> thinker朝外, 左数第22个是write。
>
> 所以眼镜藏在writer这里!
>
> 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为:
>
> 有 n个玩具小人围成一圈, 已知它们的职业和朝向。现在第11个玩具小人告诉小南一个包含m条指令的谜題, 其中第 z条指令形如“左数/右数第s,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。
>
> ## 输入格式
>
> 输入的第一行包含两个正整数 n,m，表示玩具小人的个数和指令的条数。
>
> 接下来 n行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 00 表示朝向圈内，11 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 1010 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。
>
> 接下来 m 行，其中第 i行包含两个整数 a_i,s_i，表示第 i条指令。若 a_i=0，表示向左数 s_i个人；若 a_i=1，表示向右数 s_i个人。 保证 a_i 不会出现其他的数。
>
> ## 输出格式
>
> 输出一个字符串，表示从第一个读入的小人开始，依次数完 m*m* 条指令后到达的小人的职业。
>
> ## 输入输出样例
>
> **输入 #1**
>
> ```
> 7 3
> 0 singer
> 0 reader
> 0 mengbier 
> 1 thinker
> 1 archer
> 0 writer
> 1 mogician 
> 0 3
> 1 1
> 0 2
> ```
>
> **输出 #1**
>
> ```
> writer
> ```
>
> **输入 #2**
>
> ```
> 10 10
> 1 C
> 0 r
> 0 P
> 1 d
> 1 e
> 1 m
> 1 t
> 1 y
> 1 u
> 0 V
> 1 7
> 1 1
> 1 4
> 0 5
> 0 3
> 0 1
> 1 6
> 1 2
> 0 8
> 0 4
> ```
>
> **输出 #2**
>
> ```
> y
> ```

```c++
#include<bits/stdc++.h>
using namespace std;
struct People
{
    int a;
    string name;
};

int main() {
    int n, m; 
    int idx = 0, x, y;
    cin >> n >> m;
    People P[100005];
    for(int i = 0; i < n; i++){
        cin >> P[i].a >> P[i].name;
    }
    for(int i = 0; i < m; i++){
        cin >> x >> y;
        if((P[idx].a == 0 && x == 0)||(P[idx].a == 1 && x == 1)){
            idx = (n+idx-y)%n;
        }
        else{
            idx = (idx+y)%n;
        }
    }
    cout << P[idx].name << endl;
    // cout << idx;
    return 0;
}
```

这道题还是一道简单的模拟题，这道题需要注意的是以下几点：

1. 根据我们手工模拟即可得出这个这个找小人的规律，按照题目中所描述的，如果小人面向圈内且向左数，那么就是0 0，则我们就把idx这个定位器按照逆时针的方式来移动，经过四种尝试，我们发现，如果代表圈内圈外的01和向左向右数的01异或的结果是1的话，那么我们就逆时针移动idx，对应到程序中就是用idx-n；
2. 我们这里还需要注意的一点是，idx如果向逆时针方向移动的话，那么就会出现负数的情况，我们还需要用idx去取余来计算移动的step，所以我们这里需要先给idx加一个n，避免负数的产生；

PS：这道题一开始在本地运行的时候可以，上传到OJ上发现只有80分，后来发现是数组开的不够大等等原因，导致了WA，后来把数组开大上传后发现100了，但是本地vscode中又运行不了了，发现是爆栈了。