# 1.绪论

### 2.1性能测度

>   If you can not measure it,  you can not improve it. - Lord Kelvin

### 2.2问题规模

两个主要方面：

1.  正确性：算法功能与问题要求一致？数学证明？
2.  成本：运行时间+所需存储空间  如何度量？ 如何比较？

考察： $T_A(P)$=算法A求解问题实例P的计算成本

​	但是出现的问题太多，如何归纳概括？

观察：	问题实例的*规模*，往往是决定计算成本的主要因素

通常：规模扩大；成本上升

### 2.3最坏情况

对于同一问题等规模的不同实例，计算成本不相同，甚至有实质差别

![image-20210222162621953](https://i.loli.net/2021/02/22/qGATIltuzwcNRKi.png)

对于这个问题，不同的情况下会有不同的结果，运气好的话，可能很快就得到结果，但是运气不好的话就会展现出问题的复杂……

稳妥起见，取$T(n) = max \{T(P) | |P| = n\}$，即，在规模同为n的所有实例中，只关注最坏（成本最高）者

### 2.4理想模型

同一个问题有多个算法，如何评定优劣？

~~统计是最直接的方法，但不足以反映算法的真实率~~

![image-20210222163340705](https://i.loli.net/2021/02/22/quOXjrEFIv84AP2.png)

**为了客观，所以需要抽象出一个理想的平台或模型**

### 2.5图灵机 Turing Machine

![image-20210222163721244](https://i.loli.net/2021/02/22/3D8QvfurM7FeGxd.png)

### 2.6图灵机实例

```
(<, 1, 0, L, <)	//左行，1->0
(<, 0, 1, R, >)	//掉头，0->1
(<, #, 1, R, >)	//首位如果不是0的话，需要将第一位翻成1
(<, 0, 0, R, >)	//右行
(<, #, #, L, h)	//复位
```

### 2.7RAM模型 <u>Random Access Machine</u>

![image-20210222170244080](https://i.loli.net/2021/02/22/7fbc28R4s3KPYHr.png)

| 常数赋值语句             | 间接取值$^{[1]}$      | 寄存器的加运算       |
| ------------------------ | --------------------- | -------------------- |
| 寄存器与寄存器之间的赋值 | 间接赋值              | 寄存器的减运算       |
| 条件判断语句 0判断       | 条件判断语句 正数判断 | 转向语句    终止语句 |

\[1]首先根据给定的编号j，取出编号为j的寄存器中，取出整数数值，再取对应寄存器的数值，最后将这个数值赋值给编号为i的寄存器

❗  与TM模型一样，RAM模型也是一般计算工具的简化和抽象，使得我们可以独立于具体的平台,对算法的效率做出可行的比较和评判

​	在这些模型中

​		算法的运行时间 ∝ 算法需要执行的基本操作次数

​		$T(n)$ = 算法为求解规模为n的问题,所需执行的基本操作次数

### 2.8RAM模型实例:Floor

📍功能:向下取整的除法, 	0 <= c,	0<d
![image-20210222173205215](https://i.loli.net/2021/02/22/aPGQM54c6b3jRkJ.png)

算法:反复地从R[0]=1+c中减去R[1]=d,统计在下溢之前,所作的减法次数

![image-20210222173629818](https://i.loli.net/2021/02/22/sGZojwMfD3AEb2u.png)

![image-20210222174202218](https://i.loli.net/2021/02/22/YrLU9aOnIhsRpZg.png)