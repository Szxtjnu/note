<u>***数据类型决定了程序中数据和操作的意义***</u>







# 复合类型

*复合类型*是指基于其他类型定义的类型。

>   一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。

### 引用

引用为对象起了另一个名字。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

```c++
int ival  = 1024;
int &refVal = ival;		//refVal指向ival（是ival的另一个名字)
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。当定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值对象一直绑定在一起。

##### 引用即别名

✔引用并非对象，相反的，他只是一个为了已经存在的对象起的另外一个名字。

定义了一个引用之后，对它进行的操作都是在与之绑定的对象上进行的。

为了引用赋值，实际上是把值付给了与引用绑定的对象。获取引用的值，实际上就是获取与引用绑定的对象的值。

##### 引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以&开头。

```cpp
int i = 1024, i2 = 2048;
int &r = i, r2 = i2;	//既可以连续定义引用，也可以定义int类型的新变量
```

**所有引用的类型都要和与之绑定的对象严格匹配。**

**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**

### 指针

指针，是指向另外一种类型的复合类型。与引用不同的是，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，可以先后指向不同的对象。二一个是指针无需在定义的时候就赋初值，和其他的内置类型一样，在*块作用域*内定义的指针如果没有被初始化，也将拥有一个不确定的值。

❗指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而备受折磨。

定义指针，将声明符写成\*d的形式，其中d是变量名。

##### 获取对象的地址

指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&）

```cpp
int ival = 42;
int *p = &ival;
```

注：引用不是对象，没有实际地址，所以不能定义指向引用的指针。

**所有指针的类型都要和与之绑定的对象严格匹配。**

##### 指针值

​	指针的值（也就是地址）应属于下列四种状态之一：

1.  指向一个对象；
2.  指向紧邻对象所占空间的下一个位置；
3.  空指针，意味着指针没有指向任何对象；
4.  无效指针，也就是上述情况之外的其他值；

##### 利用指针访问对象

​	如果指针指向了一个对象，则允许使用解引用符（\*）来访问该对象。

```cpp
int ival = 42;
int *p = &ival;
cout << *p;			//由符号*得到指针p所指的对象，输出42
```

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值。

```cpp
*p = 0;
cout << *p；		//输出0
```

##### 空指针

​	空指针(null pointer)不指向任何对象。

```cpp
int *p1 = nullptr;		// 等价于int *p1 = 0；
int *p2 = 0;			//直接将p2初始化为字面常量0；
int *p3 = NULL；			//等价于int *p3 = 0；
```

>   建议：初始化所有指针，在有可能的情况下，尽量等定义了对象之后再定义指向它的指针。或者可以直接初始化为nullptr

##### 赋值和指针

指针和引用都能提供对其他对象的间接访问。不同点是引用一旦被定义就，就无法再绑定其他对象，但是指针没有这样的特点。

```cpp
int i = 42;
int *pi = 0;		//pi被初始化，但没有指向任何对象，是空指针
int *pi2 = &i;		//pi2被初始化，存有i的地址
int *pi3;			//如果pi3定义于块内，则pi3的值是无法确定的

pi3 = pi2;			//pi2和pi3指向同一个对象i
pi2 = 0;			//现在pi2不指向任何对象了
```

##### 其他指针操作

指针可以用在条件表达式中，如果指针对应的值是0，则false。

```cpp
int ival = 1024;
int *pi = 0;		//pi合法，是一个NULL
int *pi2 = &ival;	//pi2是一个合法的指针，存放着ival的地址
if(pi)				//pi的值是0，因此条件的值是false
    	// ...
if(pi2)				//pi2指向ival，因此它的值不是0，条件是true
    	//...
```

>   任何非0指针对应的条件值都是true

对于两个合法指针，也可以用==或!=来比较它们，返回值是bool类型。若指针指向的是一个地址，则它们相等，反之它们不相等。

##### void* 指针

*void\**是一种特殊的指针类型，可以存放任意对象的地址。

```cpp
double obj = 3.14, *pd = &obj;
void *pv = &obj;	//obj可以是任意类型的对象
pv = pd;			//pv可以存放任何类型的指针
```

>   void*是一种无类型指针，任何类型指针都可以转化为void\*
>
>   所以，它无法进行解引用和算数运算的操作（因为不知道解引用的内存大小，以及算数运算操作的大小。

### 理解复合类型的声明

一条定义语句中，基本数据类型只能有一个，但是声明符的形式却可以不同。

##### 定义多个变量

```cpp
int* p；
int *p；
```

上面这两个定义均为相同的定义方式，均是定义int型指针p。其中\*运算符仅仅是修饰p而已。

所以

```cpp
int* p1,p2;
```

这句语句中p1是int型的指针，而p2是int型的变量；

##### 指向指针的指针

>   一般来说，声明符中修饰符的个数并没有限制。

通过\*的个数可以区分指针的级别，也就是说\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针

```cpp
int ival = 1024;
int *pi = &ival;	//pi指向一个int型的数
int **ppi = &pi;	//ppi指向一个int型的指针
```

解引用int型的指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。

##### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。

```cpp
int i = 42;
int *p;			//p是一个int型的指针
int *&r = p;	//r是一个对指针p的引用

r = &i;			//r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0;			//解引用r得到i，也就是p指向的对象，将i的值改为0
```

>   要理解r的类型到底是什么，最简单的办法就是**从右向左**阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响