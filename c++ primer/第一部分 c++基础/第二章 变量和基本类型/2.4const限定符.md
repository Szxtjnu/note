<u>***数据类型决定了程序中数据和操作的意义***</u>





# const 限定符

当我们需要定义一个值不能被轻易改变时，需要用关键字const来对变量的类型加以限定。

##### 初始化和const

const类型的对象能完成大部分非const类型对象所能完成的。主要的限定就是只能在const类型的对象上执行不改变其内容的操作。例如const int和普通int一样都能参与算数运算。

在不改变const对象的操作中还有一种是初始化。

**默认状态下，const对象仅在文件中有效**

当以编译时初始化的方式定义一个const对象时，编译器会在编译的过程中把用到该变量的地方都替换成相应的值。

为了执行这样的替换，编译器必须知道变量的初始值，如果程序包含多个文件，则用了const对象的文件都必须得能访问到它的初始值才可以。所以，如果文件中有这个变量就需要定义。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候，我们希望一种const变量初始值可以在文件之间贡献。在这种情况下，我们不希望编译器为每个文件分别生成独立的变量，我们希望这类const对象在一个文件中定义，其他多个文件中声明使用它就行。

解决的办法就是对于const变量不管是声明还是定义都添加关键字extern。

---

### const的引用

可以把引用绑定到const对象上，我们称之为**对常量的引用**

P.S.对常量的引用不能被用作修改它所绑定的对象，也就是不能对引用赋值；也不能将一个非常量引用指向一个常量对象。

##### 初始化和对const的引用

引用的类型必须与其所引用对象的类型一致，但是有两个例外。

第一个例外是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

```cpp
int i =42;
const int &r1 = i;			//允许将const int & 绑定到一个普通的int上
const int &r2 = 42;			//r1是一个常量引用
const int &r3 = r1 * 2;		//r2是一个常量引用
int &r4 = r1 *2;			//错误：r4是一个普通的非常量引用
```

当我们将一个double类型的数据，绑定到另外一种类型时，会自动生成一个副本，即临时量(temporary)，如果绑定的不是一个常量，那么通过这个引用就无法改变所引用对象的值

##### 对const的引用可能引用一个非const的对象

```cpp
int i = 42;
int &r1 = i;			//引用r1绑定对象i
const int &r2 = i;		//r2也绑定对象i，但是不允许通过r2修改i的值
r1 = 0;					//r1并非常量，i的值修改为0
r2 = 0;					//错误：r2是一个常量引用
```

### 指针和const

>   和引用类似，也可以令指针指向常量或非常量

<u>指向常量的指针</u>不能用于改变所指对象的值。

```cpp
const double pi = 3.14;
double *ptr = &pi;			//错误，ptr是一个普通指针
const doouble *cptr = &pi;	//正确，cptr
*cptr = 42;
```

和引用一样，指针的类型必须和所指的对象类型一致，但是允许一个指向常量的指针指向一个非常量的对象，

##### const指针

📍指针是对象而引用不是，因此就像其他对象类型一样 ，允许把指针本身定义为常量。*常量指针(const pointer)*必须初始化，<u>而且初始化一旦完成，它的值也就是指针指向的那个地址就不能在改变了</u>

**<u>也就是说，不能改变的是指针所指的对象，而非所指对象的值</u>**

```cpp
int errNumb = 0;
int *const curErr = &errNumb;	//curErr将一直指向errNumb
errNumb = 42;					//errNumb是可以被改变的

const double pi =3.14159;
const double *const pip = &pi;	//pip是一个指向常量对象的常量指针
```

❗想要搞清楚这些声明的含义最行之有效的办法就是从右向左阅读，在上面的例子中，距离curErr最近的符号是const，意味着curErr本身就是一个常量对象，对象的类型由声明符的其余部分确定。声明符的下一个符号是*，意思是curErr是一个常量指针。

>   示例：说出下面指针与const限定符结合后所代表的意义
>
>   1、const char *p
>
>   2、char const *p
>
>   3、char* const p
>
>   4、const char* const p
>
>   
>
>   下面介绍一个简单的判断方法：
>
>   **例1**：首先我们从右往左看，写成括号的优先级就是(const (char (*p)))，由最里面的括号可以知道p是一个指针，再到外面一个括号可以知道p是一个指向char类型的指针，再到最外面一个括号可以知道p是一个指向const char类型的指针。
>
>   
>
>   **例2**：我们也是从右往左看，写成括号的优先级（char (const (*p))），由最里面的括号可以知道p是一个指针，再到外面的括号可以知道p是一个const型指针，再到最外面一个括号可以知道p是一个指向char类型的const型指针。
>
>   
>
>   **例3**：写成括号的优先级(char (*(const p))) ，由最里面的括号可以知道p是一个const型变量，再到外面的括号可以知道p是一个const型指针，再到最外面一个括号可以知道p是一个指向char类型的const型指针
>
>   
>
>   **例4：**写成括号的优先级(const (char (* (const p))))，由最里面的括号可以知道p是一个const型变量，再到外面的括号可以知道p是一个const型指针，再到外面的括号可以知道p指向的一个const char类型的变量。

##### 顶层const

​	指针本身就是一个对象，它又可以指向另外一个对象。所以指针自己是不是一个const指针，还是指针所指的那个对象是不是一个const的对象，这就是两个问题。

​	🔎通常，用名词<u>顶层const(top-level const )</u>表示指针本身是一个常量，用名词<u>底层const(low-level const)</u>表示所指的对象是一个常量。

​	顶层const可以表示任意的对象是常量，这一点对于任意的数据类型都适用，例如算术类型、类、指针等。

​	底层const则与指针和引用等复合类型的基本类型部分有关。

```cpp
int i = 0;
int *const p1 = i；			//不能改变p1的值，这是一个顶层const
const int ci  = 42;			//不能改变ci的值，这是一个顶层const，ci不是指针，没有指向一个常量对象
const int *p2 = &ci;		//允许改变p2的值，这是一个底层const
const int *const p3 = p2;	//靠右的是顶层const，靠左的是底层const
const int &r = ci;			//用于声明引用的const都是底层const
```

❗当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中，顶层const不受影响

>   执行拷贝操作不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响

​	但是底层const的限制不能忽视，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象数据类型必须能够转换，一般来说，非常量可以转换成常量，反之则不行：

```cpp
int *p = p3;		//错误：p3包含底层const的定义，而p没有
p2 = p3;			//正确：p2和p3都是底层const
p2 = &i;			//正确：int *能转化成const int *
int &r = ci;		//错误：普通的int&不能绑定到一个int常量上
const int &r2 = i;	//正确：const int& 可以绑定到一个普通的int上
```

❗p3既是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象得是一个常量。因此，不能用p3去初始化p，因此p指向的是一个普通的（非常量）整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（顶层const）。

##### constexpr和常量表达式

**常量表达式**是指值不会该改变并且在编译过程中就能得到计算结果的表达式。

字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

>   数据类型和初始值共同决定一个对象是不是常量表达式

```cpp
const int max_files = 20;		//max_files是常量表达式
const int limit = max_files + 1;	//limit是常量表达式
int staff_size = 27;			//staff_size不是常量表达式
const int sz = get_size()		//sz不是常量表达式
```

📍constexpr变量

>   在C++11中，定义允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式

声明为<u>constexpr</u>的变量一定是一个常量，而且必须用常量表达式初始化：

```cpp
constexpr int mf = 20;			//20是常量表达式
constexpr int limit = mf + 1;	//mf + 1是常量表达式
constexpr int sz = size();		//只有当size是一个constexpr函数时候，才是一条正确的声明语句
```

普通函数不能作为constexpr变量的初始值。

允许定义一种特殊的constexpr函数，这种函数应该足够简单以使得编译时就可以直接计算其结果。

##### 字面值类型

目前为止，接触过的数据类型中，算术类型、引用和指针都属于字面值类型。

自定义类Sales_item、IO库、string 类型则不属于字面值类型，也就不能被定义成constexpr。

📍一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象

函数体内定义的变量一般没有固定地址，函数体外的对象地址不变。

##### 指针与constexpr

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：

```cpp
const int *p = nullptr;		//p是一个指向整型常量的指针
constexpr int *q = nullptr;	//q是一个指向整数的常量指针
```

