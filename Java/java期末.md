### java基本语法

#### 1.jdk jre jvm

JDK：Java标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境、以及常用的Java类库

JRE：Java运行环境，用于解释执行Java的字节码文件

JVM：Java虚拟机，是JRE的一部分。负责解释执行字节码文件，是可运行Java字节码文件的虚拟计算机

区别和联系：

JDK包含JRE、JDK和JRE中都包含JVM。JDK除了包含JRE，还包含了一些常用开发工具和基础类库

JDK用于开发，JRE用于运行Java程序

JVM是Java编程语言的核心并且具有平台独立性

#### 2.Java程序语句执行的顺序

包括四种基本控制结构：顺序结构、选择结构、循环结构（、异常处理逻辑结构）

#### 3.方法格式

```
权限修饰符	返回值声明	方法名称(参数列表){
	方法中封装的逻辑功能;
	return 返回值;
}
```

#### 4.权限修饰符

|           | 类内部 | 本包 | 子类 | 外部包 |
| :-------: | :----: | :--: | :--: | :----: |
|  public   |   √    |  √   |  √   |   √    |
| protected |   √    |  √   |  √   |   ×    |
|  default  |   √    |  √   |  ×   |   ×    |
|  private  |   √    |  ×   |  ×   |   ×    |

#### 5.注释

```java
//   /* */  /** **/
```

#### 6.关键字

| 类、方法和变量修饰符 |                |
| :------------------: | :------------: |
|       abstract       |    声明抽象    |
|       extends        |   继承、扩展   |
|        final         | 最终、不可改变 |
|      implements      |      实现      |
|      interface       |      接口      |
|        native        |      本地      |
|         new          |    新，创建    |
|        static        |      静态      |
|     synchronized     |   线程，同步   |

| 错误处理 |                        |
| :------: | :--------------------: |
|   try    |        捕获异常        |
|  catch   |        处理异常        |
|  throw   |    抛出一个异常对象    |
|  throws  | 声明一个异常可能被抛出 |

| 包相关  |      |
| :-----: | :--: |
| import  | 引入 |
| package |  包  |

| 变量引用 |            |
| :------: | :--------: |
|  super   | 父类，超类 |
|   this   |    本类    |
|   void   |  无返回值  |

#### 7.标识符定义相关

```
1.由字母、数字、下划线和$符号组成
2.不能以数字开头
3.不能是Java中的关键字
```

### 变量和常量

#### 1.变量的定义

##### 按所属的数据类型划分

1. 基本数据类型
2. 引用数据类型
	- String
	- 数组类型
	- 接口
	- 类

##### 按被声明的位置划分

1. 局部变量：方法或语句块内部定义的变量
2. 成员变量：方法外部、类的内部定义的变量

#### 2.变量的类型转换

boolean 类型不能转化为任何其他的数据类型

自动类型转换：容量小的自动转化为容量大的数据类型

> 例如:	byte, short, int 	---->	float	 ---->	long	---->	double

byte, short, int 不会互相转换，他们三者在计算的时候会转换为int类型

强制类型转换：容量大的类型转换为容量小的数据类型时，要加上强制转换符

#### 3.变量的作用域

##### 成员变量

在类体内定义的变量称为成员变量，它的作用域是整个类

##### 局部变量

在一个方法或方法内代码块中定义的变量称为局部变量

#### 4.常量

在变量声明时在语句之前添加关键字 final

### 数组的常见操作

#### 1.声明数组

```java
int a[] = new {}
```

#### 2.初始化

分为静态初始化和动态初始化两种

```java
int [] arr = {1,2,3};
int [] arr = new int[]{1,2,3,4}
```

#### 3.查看数组长度

```java
arr.length
```

#### 4.for each 循环

```java
for(int a:arr){
	System.out.println(a);
}
```

#### 5.数组的拷贝

```java
int [] arr2 = arr1;
int [] arr2 = Arrays.copyOf(arr,arr.length(自定义长度));
```

#### 6.数组排序

```java
Arrays.sort(arr);
```

#### 7.将int数组转化为字符串

```java
Arrays.toString(arr);
```

### 类与对象

#### 1.类与对象三大特征

1. 封装
	通过private, default, protected, public 关键字实现属性或者方法的封装，仅对外提供公共访问方式
	好处：实现数据项和方法的隐藏；实现隐藏隔离，允许外部对类做有限的访问，开发者可以自由的改变类的内部实现；提高了代码的重用性
2. 继承
	通过extends来实现
	好处：提高了代码的重用性；通过继承，使得对现实世界做出了更准确的建模
3. 多态
	一个对象变量可以指向多种实际类型对象的现象被称为“多态”
	三个必要条件：继承、方法的重写、父类引用指向子类对象
	好处：提高了代码的维护性（继承保证）；提高了代码的扩展性；
	Java中多态的实现方式：接口实现；继承父类进行方法重写；对同一个类中的方法重载；父类引用指向子类对象

#### 2.类与对象

```java
[修饰符] class className [extends 父类名] [implements 接口]{

}
```

#### 3.继承

##### Object类

1. getClass方法
	获取运行时类型，返回值为Class对象
2. hashCode方法
	返回该对象的哈希码值，是为了提高哈希表的性能
3. equals方法
	判断两个对象是否相等，Object源码中equals就是用==去判断，但是String以及某些特殊的类会对equals进行重写，实现自定义的比较方式
4. clone方法
	对基本数据类型字段浅层拷贝，对引用数据类型是只会复制地址
5. toString方法
	返回一个String字符串，用于描述当时对象的信息，可以重写返回对于自己有用的信息，默认返回的是当前对象的类名hashCode的16进制数字
6. wait方法
	多线程时使用到的方法，作用是让当前线程进入等待状态，同时也会让当前线程释放他所持有的锁，直到其他线程调用此对象notify()方法或者是notifyAll()方法，当前线程被唤醒
7. notify方法
	多线程使用到的方法，唤醒该对象的某个线程
8. notifyAll方法
	多线程使用到的方法，唤醒该对象等待的所有线程
9. finalize方法
	对象在被GC释放之前一定会调用finalize方法，对象被释放做最后的挣扎，因为无法确定该方法什么时候会被调用，故很少使用

#### 4.类的封装

将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来对隐藏信息 进行操作和访问

##### 封装的实现步骤

1. 修改属性的可见性为private
2. 创建getter/setter方法
3. 在getter/setter方法中加入属性控制语句

#### 5.构造方法

主要用来在创建对象时初始化对象，那为对象成员变量赋初值，终于new运算符一起使用在创建对象的语句中，一个类可以有多个构造函数，可根据参数个数的不同或参数类型的不同来区分它们，即构造函数的重载

#### 6.方法的重载与重写

##### 重载的概念

1. 必须在同一个类中
2. 方法名相同
3. 方法中参数的个数，顺序或类型不同
4. 与方法的修饰符和返回值没有关系

##### 方法重写的概念

当父类中的方法无法满足子类需求的时候，需要方法重写

##### 方法重写的注意事项

1. 重写的方法必须要和父类一模一样（包括返回值类型，方法名，参数列表）

2. 重写的方法可以使用@Override注解来标识

3. 子类中重写的方法的访问权限不能低于父类中方法的访问权限

	权限修饰符:	private	<	default	<	protected	<	public

##### 重写和重载的区别

方法的重载：在同一个类中，出现多个同名的方法，参数列表不同，与返回值类型、修饰符无关

方法的重写：子类中出现和父类中一模一样的方法（包括返回值类型、方法名、参数列表）

#### 7.this 和 super关键字

##### this

this是为了解决变量的命名冲突和不确定性问题而引入的

注：this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。原因是static方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成

##### super

1. super关键字主要存在于子类方法中，用于指向子类对象的父类对象，可以访问父类对象的属性、函数以及构造函数。
2. 子父类存在着同名的成员（包括变量和方法）时，在子类中默认是访问子类的对象，可以通过super关键字指定访问父类的成员；
3. 默认会先调用父类无参的构造函数，可以通过super关键字指定调用父类的构造函数。

#### 8.static 和 final

##### static

1. 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，不需要new一个类的实例出来
2. 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，不需要new一个类的实例出来

##### final

1. 基本类型变量使用final修饰了就不可变了
2. 对于引用类型变量被final修饰了：引用变量引用不可变，但是引用对象的内容可以改变

#### 9.抽象类

```java
public abstract class A{

}
```

1. 抽象类不能被实例化
2. 抽象类中不一定需要包含抽象方法,而且可以有实现的方法
3. 一旦一个类包含了抽象方法，那么这个类必须被生命为abstract类
4. abstract只能修饰类和方法，不能修饰属性和其他的
5. 抽象类可以拥有任意成员【抽象类的本质还是类】，比如：非抽象的方法、构造器、静态属性等
6. 抽象方法不能有主体，大括号也不行
7. 如果一个类继承了抽象类，则他必须实现抽象类的所有抽象方法，除非他自己也声明为abstract类
8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背

#### 10.接口

接口中所声明的方法都是抽象的public abstract类型

变量只能为public static final类型的

##### 接口和抽象类的区别

1. 接口要被子类实现，抽象类要被子类继承
2. 接口中变量全为公共静态常量，而抽象类中可有普通变量
3. 接口中全为方法的声明，抽象类中可以有方法的实现
4. 接口中不能有构造函数，抽象类可以有构造函数
5. 接口可多实现，而抽象类必须被单继承
6. 接口中方法全为抽象方法，而抽象类中也可以有非抽象方法

抽象类说的是是不是，接口说的是有没有

#### 11.多态

多态是同一个行为具有多个不同表现形式或形态的能力

##### 条件

1. 继承
2. 重写
3. 父类引用指向子类对象（首先检查父类中是否有该类方法，如果没有则编译错误；如果有，再去调用子类的同名方法）

##### 类型转换[从右向左看]

```java
//向上转型
class A {
	public void print(){
		System.out.println("A:print");
	}
}

class B extends A{
	public void print(){
		System.out.println("B:print");
	}
}
public void test{
	public static void main(String args[]){
		A a = new B();
		a.print();
	}
}
```

```java
//向下转型
//向下转型
class A {
	public void print(){
		System.out.println("A:print");
	}
}

class B extends A{
	public void print(){
		System.out.println("B:print");
	}
	public void funcB(){
		System.out.println("funcB");
	}
}
public class test{
	public static void main(String args[]){
		A a = new B();
		B b = (B)(a);
		b.funcB();
	}
}
```

#### 12.异常处理

程序在运行过程中，出现的非正常的情况，最终会导致Java虚拟机jvm的非正常停止

##### Throwable

- Error

	- 虚拟机错误
	- 内存溢出
	- 线程死锁

- Exception

	- 运行时异常

		- 空指针异常
		- 下标越界异常
		- 算数异常
		- 类型转化异常

		这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理

	- 非运行时异常（编译异常）

		从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过

		- IO异常
		- SQL异常

> 注：Error和Exception两者都是Java异常处理的子类，他们之间的区别是：异常可以被程序本身处理，而错误是无法处理的

##### try catch finally处理

```java
public static boolean catchFinallyTest1() {
	try{
		int i = 10 / 0;	//抛出Exception，后续处理被拒绝
		System.out.println("i value is :" + i);
		return true;	//Exception已经抛出，没有获得执行的机会
	} catch (Exception e){
		System.out.println("--  Exception --");
		return catchMethod();	//Exception抛出，执行你捕获到异常后返回的内容
	} finally{
		finallyMethod();	// Exception抛出之后，finally内的方法也会执行，除了一种情况
	}
}

/**  finally语句块不执行的情况
	1.System.exit(0),它表示退出当前Java虚拟机
	2.当线程为守护线程，如果主线程死亡，finally不执行
	（守护线程是个服务线程，准确的来说是服务其他的线程，当非守护线程停止，守护线程才会停止）

*/
```

##### throws throw 两个抛出异常的关键字

```java
// throws是方法可能抛出异常的声明。（用在声明方法时，表示该方法可能要抛出异常）
public void doA(int a) throws Exception1,Exception3{
...
}
// throw 是语句
	try{
        ...
    }catch(Exception1 e){
        throw e;
    }
```

#### 13.多线程

##### Java线程的基本状态

1. 新建状态new
	当线程对象创建后，即进入了新建状态。如Thread th = new Mythread();
2. 就绪状态Runnable
	当调用线程对象的start() 方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了该方法此线程就会立即执行
3. 运行状态Running
	当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。就绪状态是进入运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须要处于就绪状态之中
4. 阻塞状态Blocked
	处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入就绪状态，才有机会被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：
	1. 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
	2. 同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程所占用），它会进入到同步阻塞状态
	3. 其他阻塞：通过调用线程的sleep()或join()或发出了IO请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或IO处理完毕时，线程重新转入就绪状态
5. 死亡状态Dead
	线程执行完了或者因异常退出run()方法，该线程结束生命周期

##### Java中线程的创建方式

```java
class MyThread extends Thread {
	private int i = 0;
    
}
```

