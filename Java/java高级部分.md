### 类变量和类方法

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

#### 类变量的使用细节

1. 什么时候需要使用类变量？
	当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）
2. 类变量与实例变量区别
	类变量是该类的所有对象共享的，而实例变量是每个对象独享的
3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
4. 类变脸可以通过 类名.类变量名  或者 对象名.类变量名 来访问，但java设计者推荐我们使用类名.类变量名方式访问。前提是满足访问修饰符
5. 实例变量不能通过类名.变量名来访问
6. 类变量是在类加载的时候就已经初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了
7. 类变量的生命周期是随着类的加载开始，随着类的消亡而销毁

#### 类方法的介绍

类方法也叫静态方法，定义方式和调用方式与类变量类似

#### 类方法的经典使用场景

当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率

#### 类方法的细节

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：
	类方法中无this的参数
	普通方法中隐含着this的参数
2. 类方法可以通过类名调用，也可以通过对象名调用
3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用
4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以。
5. 类方法中只能访问静态变量或静态方法
6. 普通成员方法，既可以访问普通变量，也可以访问静态变量

---

### Main 方法的语法

1. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public
2. java虚拟机在执行main()方法的时候不需要创建对象，所以该方法必须是static
3. 该方法接收String类型的数组参数，该数组中保存执行java命令时，传递给所运行的类的参数
4. java执行的程序  参数1   参数2   参数3

##### 特别提醒

1. 在main() 方法中，我们可以直接调用main方法所在类的静态方法或静态属性
2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员

---

### 代码块

#### 基本介绍

代码块又称为初始化块，属于类中的成员（即是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过{}包围起来

但是和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用

#### 注意

1. 修饰符可选，要写的话也只能写static
2. 代码块分为两类，使用static修饰的叫做静态代码块，没有static修饰的，叫做普通代码块
3. 逻辑语句可以是任意逻辑语句
4. “；”可以写，也可以省略

#### 代码块的好处和案例演示

1. 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
2. 场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

#### 代码块的使用注意事项和细节讨论

1. static代码块也叫静态代码块，作用就是对类进行初始化，而且他随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行
2. 类会在什么时候被加载
	- 创建对象实例时
	- 创建子类对象实例，父类也会被加载
	- 使用类的静态成员时（静态属性，静态方法）
3. 普通的代码块，在创建对象实例时，会被隐式的调用。
    被创建一次，就会调用一次，如果只是使用类的静态成员，普通代码块并不会执行
4. 创建一个对象时，在一个类调用顺序是
  - 调用静态代码和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态属性初始化，则按他们的顺序调用）
  - 调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级是一样的，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
  - 调用构造方法
5. 构造器的最前面其实隐含了super()和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕了，因此是优先于构造器和普通代码块执行的
6. **创建一个子类对象时，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下**
  1. 父类的静态代码块和静态属性初始化（优先级一样，按照定义顺序执行）
  2. 子类的静态代码块和静态属性初始化（优先级一样，按照定义顺序执行）
  3. 父类的普通代码块和普通属性初始化
  4. 父类的构造方法
  5. 子类的普通代码块和普通属性初始化
  6. 子类的构造方法
7. 静态代码块只能调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员

----

### Final关键字

final可以修饰类、属性、方法和局部变量.

在某些情况下，程序员可能由以下需求，就会使用到final：

1. 当不希望类被继承时，可以用final修饰
2. 当不希望父类的某个方法被子类覆盖/重写时，可以用关键字final修饰
3. 当不希望类的某个属性的值被修改，可以用final修饰
4. 当不希望某个局部变量被修改，可能使用final修改

#### final的使用细节

1. final修饰的属性又称为常量，一般用XX_XX_XX来命名
2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一
	1. 定义时
	2. 在构造器中
	3. 在代码块中
3. 如果final修饰的属性时静态的，则初始化的位置只能是
	1. 定义时
	2. 在静态代码块中
4. final类不能继承，但是可以实例化对象
5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承
6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法
7. final不能用来修饰构造器
8. final和static往往搭配使用，效率更高
9. 包装类(Integer/Double/Float/Boolean)，String都是final类

---

### 抽象类

当父类的一些方法不能确定的时候，可以用abstract关键字来修饰这个方法， 这个方法就是抽象方法，用abstract来修饰该类就是抽象类。

1. 用abstract关键字来修饰一个类的时候，这个类就叫抽象类
	访问修饰符 abstract 类名
2. 用abstract来修饰一个方法的时候，这个方法就是抽象方法（无方法体，大括号也不能有）
3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现

#### 抽象类的细节

1. 抽象类不能被实例化
2. 抽象类中不一定需要包含抽象方法,而且可以有实现的方法
3. 一旦一个类包含了抽象方法，那么这个类必须被生命为abstract类
4. abstract只能修饰类和方法，不能修饰属性和其他的
5. 抽象类可以拥有任意成员【抽象类的本质还是类】，比如：非抽象的方法、构造器、静态属性等
6. 抽象方法不能有主体，大括号也不行
7. 如果一个类继承了抽象类，则他必须实现抽象类的所有抽象方法，除非他自己也声明为abstract类
8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背

---

### 接口

#### 基本介绍

接口就是给出一些没有实现的方法，封装到一起，到某个类要是用的时候，再根据具体情况把这些方法给写出来

> 注：
>
> 1. 在Jdk7.0以前，接口里的所有方法都没有方法体
> 2. JDK8.0后的接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现

#### 接口细节

---

### 多线程基础

#### 线程使用

##### 创建线程的两种方法

###### 继承方法

1. 当一个类继承了Thread类，该类就可以当做线程使用
2. 一般来说会重写run方法，写上自己的业务代码
3. run Thread类实现了Runnable接口的run方法

###### Runnable方法

1. 由于java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然是不可能的
2. Java的设计者们提供了另外一种方式创建线程，就是通过实现Runnable接口来创建线程

> 两种创建线程方式的区别：
>
> 1. 从Java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口start
> 2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制

----

### 内部类

#### 内部类的分类

##### 定义在外部类局部位置上

1. 局部内部类（有类名）

	> 说明：局部内部类时定义在外部类的局部位置，比如在方法中，并且有类名
	>
	> 1. 可以直接访问外部类的所有成员，包含私有的
	> 2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用访问修饰符的。但是可以使用final修饰。
	> 3. 作用域：仅仅在定义它的方法或者代码块中
	> 4. 局部内部类可以直接访问外部类的成员
	> 5. 外部类在方法中，可以创建局部类的对象实例，然后调用方法即可
	> 6. 外部其他类不能访问局部内部类
	> 7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则， 如果想访问内部类的成员，则可以使用（外部类名.this.成员）

2. 匿名内部类（没有类名，重点）

	> 注意：
	>
	> 1. 匿名内部类既是一个类的定义，同时它本身也是一个对象。因此从语法上来看，它既有定义类的特征，也有创建对象的特征。
	> 2. 可以直接访问外部类的所有成员，包含私有的
	> 3. 不能添加访问修饰符，因为它的地位就是一个局部变量
	> 4. 作用域：仅仅在定义它的方法或代码块之中
	> 5. 匿名内部类可以直接访问外部类的成员
	> 6. 外部其他类不能访问匿名内部类
	> 7. 如果外部类和外部类的成员重名时，内部类访问的话，默认遵循就近原则， 如果想访问外部类的成员，则可以使用（外部类名.this.成员)去访问

##### 定义在外部类的成员位置上

1. 成员内部类（没有用static修饰）

	> 说明：成员内部类是定义在外部类的成员位置，并且没有static修饰
	>
	> 1. 可以直接访问外部类的所有成员，包含私有的
	> 2. 可以添加任意访问修饰符，因为它的地位就是一个成员
	> 3. 作用域：和外部类的其他成员一样，作用域为整个类体
	> 4. 成员内部类访问外部类成员可以直接访问
	> 5. 外部类访问成员内部类需要先创建成员内部类的对象，再访问
	> 6. 外部其他类访问成员内部类

2. 静态内部类（使用static修饰）

	> 说明：静态内部类是定义在外部类的成员位置，并且有static修饰
	>
	> 1. 可以直接访问外部类的所有静态成员包含私有的，但不能直接访问非静态成员
	> 2. 可以直接添加任意访问修饰符，因为它的地位就是一个成员
	> 3. 作用域：同其他的成员，为整个类体
	> 4. 静态内部类可以直接访问所有外部类的静态成员
	> 5. 外部类访问静态内部类的时候需要先创建对象，再访问

	

---

### Java 异常

#### 基本概念

Java程序中，将程序执行中发生的不正常情况称为“异常”。

执行过程中所产生的异常事件可以分为两类：

1. Error（错误）：Java虚拟机无法解决的严重问题.例如：JVM系统内部出错、资源耗尽等严重问题。Error是严重错误，程序会崩溃
2. Exception：其他因变成错误或偶然的外在因素导致的一般性问题，可以使用针对性代码进行处理。例如：空指针访问，试图读取不存在的文件，网络连接中断等等。Exception通常分为运行时异常和编译时异常。

#### 运行时异常

1. NullPointerException
	当应用程序试图在需要对象的地方使用null时，抛出该异常
2. Arithmetic Exception
	当出现异常的运算条件时，抛出该异常
3. Array Index Out Of Bounds Exception
	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引
4. Class Cast Exception
	当视图将对象强制转化为不是实例的子类时，抛出该异常
5. Number Format Exception
	当应用程序视图将字符串转化成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常

#### 异常处理

##### try-catch-finally

> 注：
>
> 1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch
> 2. 如果异常没有发生，则顺序执行try的代码块。不会进入catch
> 3. 如果希望不管是否发生异常，都要执行某段代码，则需要将其写入finally之中
> 4. 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，只会匹配一个catch

##### throws

基本介绍：

1. 如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理
2. 在方法声明中throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类

> 注意：
>
> 1. 对于编译异常，程序中必须有相应的处理
> 2. 对于运行时异常，程序中如果没有处理，默认的方式就是throws的方式处理
> 3. 子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型
> 4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws

##### throw 和 throws 区别

|        | 意义                     | 位置       | 后面跟的东西 |
| ------ | ------------------------ | ---------- | ------------ |
| throws | 异常处理的一种方式       | 方法声明处 | 异常类型     |
| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象     |

---

### 集合

#### 集合的理解和好处

数组的不足

1. 长度开始时必须制定，而且一旦制定，不能更改
2. 保存的必须为同一类型的元素
3. 使用数组进行增加/删除元素的时候比较麻烦

集合

1. 可以动态保存任意多个对象，使用比较方便
2. 提供了一系列方便的操作对象的方法：add, remove, set, get等
3. 使用集合添加/删除元素方便

#### 集合的框架

##### Collection(单列集合)

- List
	- Vector
	- ArrayList
	- LinkedList
- Set
	- TreeSet
	- HashSet

##### Map(双列集合)

- HashMap
	- LinedHashMap
- TreeMap
- Hashtable
	- Properties

#### Collection接口和常用方法

##### Collection接口实现类的特点

1. collection实现子类可以存放多个元素，每个元素可以是Object
2. 有些collection的实现类，可以存放重复的元素，有些不可以
3. 有些collection的实现类，有些是有序的(List)，有些不是有序的(Set)
4. collection接口没有直接的实现子类，是通过它的接口Set和List来实现的

##### Collection接口遍历元素的方式-使用Iterator（迭代器）

1. Iterator对象成为迭代器，主要用于遍历Collection集合中的元素
2. 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器
3. Iterator仅用于遍历集合，本身并不会存放对象
4. Iterator遍历完一遍后，如果希望再次遍历，则需要重置迭代器

#### List接口和常用方法

##### List接口基本介绍

1. List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复
2. List集合中的每个元素都有其对应的顺序索引，即支持索引
3. List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素

#### ArrayList的注意事项

1. ArrayList可以加入null，且可以加入多个
2. ArrayList是由数组来实现数据存储的
3. ArrayList基本等同于Vector，但ArrayList是线程不安全的

#### Vector的基本介绍

1. Vector底层也是一个对象数组
2. Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized
3. 在开发中，需要线程同步安全时，考虑使用Vector

#### Set接口和基本方法

1. 无序（添加和取出的顺序不一致），没有索引
2. 不允许重复元素，所以最多包含一个null
3. Set接口和Collection接口的常用方法一样
4. 和Collection的遍历方式一样，因为Set接口是Collection接口的子接口，所以
	1. 可以使用迭代器
	2. 可以使用增强for
	3. 不能使用索引的方式来获取

#### HashSet的说明

1. HashSet实现了Set接口
2. HashSet实际上是HashMap
3. 可以存放null值，但是只能有一个null
4. HashSet不保证元素是有序的，取决于hash后，再确定索引的结果
5. 不能有重复元素/对象

### Map接口

1. Map和Collection并列存在。用于保存具有映射关系的数据：Key-Value
2. Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中
3. Map中的key不允许重复，原因和HashSet一样
4. Map中的value可以重复
5. Map中的key可以为null，value也可以为null，但key只能有一个null，但是value可以有多个null
6. 常用String类作为Map的key
7. key和value之间存在单向一对一的关系，即通过指定的Key总能找到对应的Value

#### Map接口的常用方法

1. put
2. remove
3. get
4. size
5. isEmpty
6. clear
7. containsKey