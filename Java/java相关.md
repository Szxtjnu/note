#### 继承的特性

1. 作为子类，不能够调用父类private属性的参数和方法，可以使用间接方式调用。且子类在继承时是完全将父类的参数和方法继承下来，只是不能够使用

2. 作为子类，在构造器构造子类的对象的同时，会自动调用父类的无参构造器

	会默认在子类的构造器中添加一个super(); 的函数，作用是调用父类的无参构造器 

3. 如果父类没有提供无参构造器，那么就必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译时无法通过的。

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下: super()

5. super在使用时，需要放在构造器的第一行，super()只能在构造函数中使用

6. super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在同一个构造器之中

7. java中的所有类都是Object类的子类，Object是所有类的基类

8. 父类构造器的调用不限于直接父类，将一直向上追溯直到Object类

9. 子类最多只能继承一个父类（指直接继承）即java中是单继承机制。

10. 不能滥用继承，子类和父类之间必须满足is-a 的逻辑关系

#### Super

##### 基本介绍

super代表父类的引用，用于访问父类的属性、方法、构造器

1. 不能访问private
2. 可以访问父类的构造器

##### 注意事项

1. 调用父类构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）
2. 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super，this，直接访问是一个效果。

|   区别点   |                          this                          |                   super                    |
| :--------: | :----------------------------------------------------: | :----------------------------------------: |
|  访问属性  | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 |              访问父类中的属性              |
|  调用方法  |  访问本类中的方法，如果本类没有此方法则从父类继续查找  |            直接访问父类中的方法            |
| 调用构造器 |          调用本类的构造器必须放在构造器的首行          | 调用父类的构造器，必须放在子类构造器的首行 |
|    特殊    |                     表示当前的对象                     |            子类中访问父类的对象            |

#### 方法重写/覆盖

##### 满足条件

1. 子类的方法的**参数、方法名称**要和父类的方法的参数，方法名称一致
2. 子类方法的返回类型要和父类方法的返回类型一样，或者是父类返回类型的子类
3. **子类方法不能缩小父类方法的访问权限**

##### 方法重写 vs. 方法重载

| 名称 | 发生范围 |  方法名  |              形参列表              |                          返回类型                          |               修饰符               |
| :--: | :------: | :------: | :--------------------------------: | :--------------------------------------------------------: | :--------------------------------: |
| 重载 |   本类   | 必须一样 | 类型，个数或者是顺序至少有一个不同 |                           无要求                           |               无要求               |
| 重写 |  父子类  | 必须一样 |                相同                | 子类重写的方法返回的类型和父类返回的类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |

#### 多态

##### 编译类型和运行类型

1. 一个对象的编译类型和运行类型 可以不一致
2. 编译类型在定义对象时，就已经确定了，不能改变
3. 运行类型是可以变化的
4. 编译类型看定义时等于号的左边，运行类型看等于号的右边

##### 多态的细节

###### 多态的前提是

两个对象（类）存在继承关系

###### 多态的向上转型

1. 本质：父类的引用指向了子类的对象
2. 语法：父类类型    引用名 = new 子类对象（）；
3. 特点：编译类型看左边，运行类型看右边
	可以调用父类中的所有成员（必须遵守访问权限）
	不能调用字类中的特有成员
	最终运行效果看子类的具体实现

###### 多态的向下转型

1. 语法：子类类型 引用名 = （子类类型）父类引用；
2. 只能强制转化父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是当前目标类型的对象
4. 可以调用子类类型中所有的成员

---

属性没有重写之说，属性的值直接看编译类型；

instanceOf 比较操作符，用于判断对象的类型是否为XX类型或者是XX类型的子类型

---

#### java的动态绑定机制

1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
2. 当调用对象属性时，没有动态绑定机制，哪儿声明，哪儿使用

---

#### Equals 方法

==和Equals的对比

1. ==是一个比较运算符，既可以判断基本类型，又可以判断引用类型
2. ==如果判断基本类型，判断的是值是否相等。
3. ==如果判断引用类型，判断的是地址是否相等，即判定是不是同一个
4. equals，是Object类中的方法，只能判断引用类型 
5. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer, String

---

#### hashCode方法

1. 提高具有哈希结构的容器的效率
2. 两个引用，如果指向的是同一个对象，那么哈希值肯定是一样的
3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的
4. 哈希值主要是根据地址号来的，不能完全将哈希值等价于地址
5. obj.hashCode()
6. 后面在集合中hashCode也会需要重写

---

#### toString 方法

默认返回的是全类名+@+哈希值的十六进制

子类往往重写toString方法，用于返回对线的信息

---

#### finalize方法

1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象之前，会先调用finalize对象
3. 垃圾回收机制的调用，是由系统来决定的，也可以通过System.gc()主动触发垃圾回收机制
